*Dribble* - embedded CEP engine
===============================

Build status (master): [![Build Status](https://travis-ci.org/konrads/dribble.svg?branch=master)](https://travis-ci.org/konrads/dribble)

A CEP library with an OTP application layer. Based on:
* [beam-erl v0.2.0](https://github.com/darach/beam-erl/tree/v0.2.0/src)
* [eep-erl](https://github.com/darach/eep-erl)

As a libary, *dribble* facilitates construction of algorithms via DSL. An algorithm is implemented by a single beam flow, and consisting of beam filters|transforms|branches and more complex constructs - `plugins`. A `plugin` provides a runtime behaviour that manipulates stream events and `plugin` context (partition of beam_flow context), wrapped up in a beam sub-flow. Common `plugin` implementations such as eep `windows` are promoted to first class *dribble* citizens by implementing a plugin behaviour that defines custom DSL and auto wire-up functionality.

As an OTP application, *dribble* provides a thin process layer to manage algorithms, expose public endpoints, drive eep `window` clock ticks. Further functionality - to be considered...

Sample usage
------------

First, create some helper functions used in filtering/transformation of data:

``` erlang
% helpers
Eq = fun(Path, ExpVal) -> fun(Data) -> proplists:get_value(Path, Data) =:= ExpVal end end,
And = fun(Predicates) -> fun(Data) -> lists:usort([ P(Data) || P <- Predicates]) == [true] end end,
IsOffline = And([Eq(uptime, -1), Eq(logical_group, "ap")]),
IsOnline  = And([Eq(uptime,  0), Eq(logical_group, "ap")]),
GroupBy = fun(Data) -> kvlists:get_value(device_id, Data) end,
Last = fun([]) -> []; (Ctx) -> [lists:last(Ctx)] end,
ToAlert = fun(Type) ->
    fun(Data) ->
        [{alert_type, Type},
         {device_id,  proplists:get_value(device_id, Data)}]
    end
end.
```

Next, configure an algorithm in *dribble* DSL. Note, quoted 'atoms' represent user defined labels, unquoted atoms - DSL syntax.

``` erlang
Algo = {algorithm,
    {flows, [
        {in, public, [{branch, [offline, online]}]},
        {offline, internal, [
            {filter, is_offline, {fn, IsOffline}},
            {transform, to_alert, {fn, ToAlert("offline")}},
            {branch, [output]}]},
        {online, internal, [
            {filter, is_online, {fn, IsOnline}},
            {transform, to_alert, {fn, ToAlert("offline")}},
            {branch, [output]}]},
        {output, internal, [
            {plugin, dribble_window, stabilizer_win},
            {sink, out}
        ]}
    ]},
    {plugin_defs, [
        {dribble_window, [
            {stabilizer_win, [
                {type, tumbling},
                {axis, time},
                {clock_interval, 50},
                {emit, {fn, Last}},
                {group_by, {fn, GroupBy}}
            ]}
        ]}
    ]}
}.
```

To run as a process-less library, push through both events and clock ticks:
``` erlang
Ctx = dribble:new(Algo),
EventIn = [{device_id,     "#123"},
           {uptime,        -1},
           {logical_group, "ap"}],
% push events in, they'll be aggregated in a time based window, with last event emitted after clock tick at 50ms
{[], Ctx2} = dribble:push(Ctx, in, EventIn),
% getting alert in `out` sink
{[{out, [ [{alert_type, "offline"}, {device_id, "#123"}] ]}], Ctx3} = dribble:tick(Ctx2, stabilizer_win).
```

As OTP app, clock ticks are generated by the application:
``` erlang
application:load(dribble),
application:set_env(dribble, tick_freq, 100),                  % tick every 100 ms
application:start(dribble),
{ok, Pid} = dribble:start_link(my_algo, AlgoDSL),
% to get existing algo
{ok, Pid} = dribble:get_instance(my_algo),
{ok, Res2} = dribble:push(Pid, Event1),
{ok, Res3, AuditLog3} = dribble:push(Pid, Event2, true).       % with audit
```

Where:
* Res1/2/3/4 - map of results, if any any generated, eg. [{output_sink, Val}], or []
* AuditLog3 - audit log on filters, transformers, branches, windows

Other examples
--------------

For more examples, check out [test/dribble_examples_SUITE.erl](https://github.com/konrads/dribble/blob/master/test/dribble_examples_SUITE.erl).


Implementation
--------------

Pipes, branches, transforms and filters have a 1-to-1 mapping with beam constructs. `Windows` restructure parent pipelines, potentially generating more pipelines for time based windows.

Algorithm construction requires multiple passes, eg.
* determine used plugins
* generate all beam pipes, for both flows and `windows`
* fill in in all pipes, generic or `window`
* validate no cyclic graphs, no dead ends

`window` construction is delegated to dribble_window. Flows, which drive the entire construction, get a preferential treatment and hence differ from plugins.


TBD
---

* Clock ticks in OTP app - should they be part of algorithm, driven externally?
* System events - should be done on the OTP app layer. Processes at that level have access to the flow (for eg. `tick`) and beam context (for eg. hinted handoff)
* beam_flow:minimize/optimize/flatten() - denormalize 1-to-1 branches into single pipes, for speed
